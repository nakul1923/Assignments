                                    17/12/2024

			             2D Array 

We can consider 2D array as a matrix where rows and columns will be there

Total number of elements in a 2D array will be row size x Column size

                           

                             #OOPs

                             # Class

Class is a Collection of data members and methods.

Class is a building block.

Object is an instance of a class once a class is define we can create any number of objects to that class.


                          # return(Keyword)

By using this we can return value form called method to calling method.

                          #this(keyword)

It is a keyword which represents current object. If local variable and data members are same than this keyword is used to differentiate.


                          # Encapsulation

Wrapping of data and methods in a single unit is called encapsulation the data is not accessible from outside world directly only with the help of methods we can access the data.

Example:

class Employee{
	
	int id;
	String name;
	double salary;
	String address;
	long mobile;
	boolean status;
}




                             20/12/2024

# Types of data members in a class

In java data members can be of two types

1. Static data members.
2. Non-static data members.

1) Static data members are those which are class level variables only one copy of this members will be created and all the objects will share that members.

To access static data members we do not require any object.

# Types of methods in java

1. Static methods.
2. Non-static methods.

1) Static methods are those methods which are class level methods.

To access static methods we do not need any object.

We can static methods using class name.

NOTE: We cannot use non-static members inside the static methods directly


                           # Constructors

Constructor is a special method which is used to initialize data members of a class.

Constructor name is same as class name.

Constructor are called automatically when the objects are created.

# Types of Constructor

There are two types of constructor.

1. Default Constructor.
2. Parameterized Constructor.

1) Default constructor - If constructor does not have any parameter than it is called default constructor/Non-parameterized constructor.

There are two types of default constructor.

a. System define default constructor 
b. User define default constructor.

a) System define default constructor - If there is no constructor in the class than system generate one constructor called system define default constructor.

b) User define default constructor - If user is creating constructor without any parameter than it is called user define default constructor.

2) Parameterized constructor - Constructor with parameter is called parameterized constructor.

This constructor receives value while creating the object.

NOTE: constructor may or may not be private.



                              23/12/2024

# Object parameterized constructor

The constructor which receives object as a parameter is called object parameterized constructor.

This constructor is used to copy values of one object into another object.


                             # Polymorphism

Poly is many and morphism is forms defining one thing in many forms is called polymorphism.

There are two types of polymorphism.

1. Compile-time polymorphism - Method overloading
2. Runtime polymorphism - Method overriding.

                           1) Method overloading 

Writing methods with same name by changing signature is called method overloading.

Signature means numbers of parameters should be different or types of parameter should be different or order of parameter should be different.



                                26/12/2024

# Command line Argument

Accepting the data dynamically from the command prompt known as command line arguments.

The number of values passed to the java program from the command prompt is known as command line arguments.

All the command line arguments are by default available in the form of array of objects of string class in main method of java.


                             # Inheritance

The mechanism of getting the data members and methods of base class in the derived class is inheritance.

Example:-

class A{             //Base class

}

class B extends {           //Child class

}

In java one class can extends only one other class means java will not support multiple inheritance.

class A             class B               

class C extends A,B       (this is not allowed in java)

If we do not want to give the features of base class to the child class then the definition of the base class must be made as 'final'.

If we don't want to give some of the features of base class to the child class than we make that features private.

Types of Inheritance

1) Single inheritance - When a class is derived from single base class then it is called single inheritance.

2) Multilevel inheritance - If a class is derived from another derived class than it is called multilevel inheritance

Example:-

class A{}

class B extends A{}

class C extends B{}

3) Hierarchical inheritance - When more than one classes are derived from single base class than it is called hierarchical inheritance.

Example:-

class A{}

class B extends A{}

class C extends A{}

4) Hybrid inheritance - It is a combination of two or more inheritance

Example:-

class A{}

class B extends A{}

class C extends B{}

class D extends B{}



                               27/12/2024

                            # super(Keyword)

super is a keyword created by JVM and supplied to each & every java program to differentiate between base class features and derived class features.

Base class features and derived class features is may same than super keyword is used.

#super at variable level - 

If data member of base class and derived class are same then super keyword is used to represent base class member.

# super at method level - 

When base class and child class methods are same then to call base class methods from the child class super keyword is used.

# super at constructor level - 

Whenever we create an object of child class then first the memory space for base class is created. It means the data member of base class will be initialized first then data member of child class will be initialized. It means the constructor of base class will be executed first then the constructor of child class will be executed.


There are two types of initialization block 

1. Instance

2. Static

1) instance - For every object creation instance initialization block will be called

This block will be called before the constructor.

We can have more than one instance initialization block in our program. In that case they will be executed from top to bottom.

2) static initialization block 

Whenever a class is loaded in memory than static initialization block will be executed.

Whenever we call any executable block than class is loaded in memory.

class will be loaded in memory only once.

# Constructor chaining and initialization block

Whenever we are returning back from super class for the first time then all the instance initialization block will be executed.



                             03/01/2025

                        # Method overriding

The process of redefining the base class methods in the child class is called method overriding.

In method overriding name and signature of base class method and child class methods should be same.

# Dynamic binding/ Late binding/ Runtime binding

Which method will be called if this decision is taken at runtime then it is called runtime binding.

Rules :- 

1) In method overriding super class return type and sub class return type must be same if it is primitive.

If the return type is derived in overriding then the sub class overriding method can have the same class return type or it can have the sub class return type but it cannot have super class name return type.



                            04/01/2025


# Overriding rules related to access specifiers:-

There are 4 access specifiers in java

1) private
2) default
3) protected
4) public 

# Overriding rules related to static keyword:-

In case of static method base class is having static keyword then it is compulsory to give static in child class also.

NOTE:- If we are writing static methods then there will not be any dynamic binding. In that case only base class methods will be called.

In case of attributes there is no any dynamic binding.



                              06/01/2025

                           # Abstract class

In java programming we have two types of classes

1. concrete
2. abstract

A concrete class is a class which contain fully defined methods.

Defined methods of a class are also known as implemented or concrete methods.

Once class is concrete we can create objects directly.

2) Abstract

An abstract class is a class which contain some defined methods and some undefined methods.

undefined methods of java are also known as abstract methods.

An abstract method is a method which contain only declaration but not body.

Rules related to abstract class

1. we cannot use final keyword with abstract class

2. we cannot make abstract method as a final.

3. we can have constructor inside the abstract class

4. we cannot use abstract keyword with constructor.

5. we cannot use abstract keyword with attributes.

6. we cannot use abstract keyword with defined methods.

Defining the abstract method in child class is called implementation.

Implementation rules is similar to overriding.

For implementation the name and signature should be same in both base and child.

# Drawbacks of abstract class

1. With the help of abstract class we cannot achieve 100% abstraction because it contains define methods and constructors.

2. With the help of class concept we cannot achieve multiple inheritance.



                            07/01/2025

                          #final(keyword)

final is a keyword it is applicable for

1. classes
2. attributes
3. method

1) final for class :-

final class cannot be inherited 

2) final for attributes :- final attributes does not have default value, we cannot change the value of final attribute.

final attribute can be initialize at the time of declaration or constructor or instance initialization block.

If we initialize final attribute in the constructor then it is compulsory to initialize in each and every constructor.


# static final attribute

We can initialize static final at the time of declaration or static initialization block.

3) final for methods

final methods cannot be redefine in the child class means we cannot override final methods.

# Some important questions

1. can we overload abstract method - yes

2. can we overload final method - yes

3. can we override abstract method - yes

4. can we override final method - No

5. can we override static method - No

6. can we overload static method - yes

7. can we use static keyword with class - No

8. can we make abstract method as a final method - No

9. can we use abstract keyword with static keyword - No

10. can we use abstract keyword with private keyword - No

 


                            08/01/2025


                            #Interface

Interface is a collection of public static final data members and public abstract methods.

Interface participate in multiple inheritance.

Interface contains abstract methods but after java 1.8 we can add default and static methods in the interface.

After java 1.9 we can add private methods inside the interface.

Data members of interface must be initialized at the time of declaration only.

There is no static block, no constructor, no instance initialization block in interface.

We cannot create object for interface.





				10/01/2025

# Default methods in interface

After java 1.8 we can give body of the methods inside the interface with the help of default keyword.

By default access specifier of default method in interface is public.

NOTE:- Access specifier of a method in interface is public.

# Static method in interface.

After java 1.8 we can give static methods inside the interface.

This static methods will have body we cannot use default and static keyword together.

# private methods in interface

After java 9 we can have private methods inside the interface.

We can give body of this private method inside the interface.

These methods can only be used within the interface itself.




                             13/01/2025

                              # Package

The limitations of inheritance is that the features of base class gets inherited in child class but within the same file but if we want to give properties of a class present in one file into a class present in another file, then we use packages.

A package is a collection of classes, interfaces and sub-packages.

If we want to give any class or interface to many number of java programmers then such classes and interfaces must be placed in a package hence classes and interfaces of package will be common for many java programmers.

# Types of packages

There are two types of packages.

1. predefine packages
2. user define packages.

Predefine packages are those which are developed by son microsystem and supplied as a java software to deal with universal requirements.

Predefine packages are :-

1. java.lang.* - This package is used to achieve language functionality this is one of the package which is imported to each and every program hence it is called default package.

2. java.io.* - This package is used for input/output operations.

3. java.util.* - This package is also known as collection package, All the collection related classes are available inside the package.

# user define packages - 

User define packages are those which are developed by java programmer and supplied as a part of their project to deal with common requirements.

Syntax:-

package packageName;

Here package is a keyword use to create user define package.

Rules for creating package:-

1. The access specifier of the class or interface must be public.

2. The specifier of the constructor of the class which is present in the package must be public.

3. The specifiers of the method present in the class must be public.




                                   16/01/2025

# Number of ways to refer package

1. Using import keyword

2. By using fully qualified name/colonical form

example: - 

public class Demo{

	psvm{

		p1.test obj1 = new p1.Test();
		p2.Test obj3 = new p2.Test3();
	}

}


 				# static import

static import is a feature introduce in java version-5, which is used to allow public static members of one package into another package directly.

If there is static method with same name is already present in class then if we use import then the local method executes.


                                  # String class

String class is available in java.lang package.

String contains collection of characters

# String creation

There are different ways by which we can create String.

1. We can create string just by assigning a group of characters to a string

	String str = "hello";

it is called String literal.

2. We can create an object to a string class by allocating memory using "new" keyword

	String s = new String("hello");

3. Another way of creating String is by converting the character array into string.

	Char str[] = {'A','B','C'}

	String s = new String(str);

# String class methods 

1. String concat(String) :- this method is used to append one string into another String.

2. int length(); - This methods is used to find length of a string.

3. Char charAt(int) - This method will return character from the particular index.

4. int compareTo(String) - This method will compare two String and return UNICODE different of first mismatch character.

5. int compareToIgnoreCase(String s) - This method will compare two Strings where case will be ignored.

6. Boolean equals(String s) - equals method is used to compare two Strings.

7. Boolean equalsIgnoreCase

8. Boolean startWith(String s) - This method return true if our String will start with a given String.

9. Boolean endsWith(String) - This method test the ending of the String.

10. int indexOf(String s) - This method provide the index of a particular String.

11. int lastIndexOf(String s) - This method will provide index of a last occurrence of a character.

12. String toUpperCase(); - it will convert a String into uppercase.

13. String toLowerCase();

NOTE: - All the Strings will be stored in some specific region, called String pull which has two partitions.

1. constant pull
2. Non-constant pull

1) Constant pull - All the string literals will be stored or created in constant pull.

2) In constant pull first JVM will check whether there is an existing object with some content then in that case new object will not be created. It will point to the same object.

2) Non-constant pull - If String object is created dynamically then they are stored in Non-constant pull

In Non-constant pull when we create object then every time new object is 
created.

NOTE:- String is a immutable object in java If we can change the content of the object then it is called mutable.





                                   18/01/2025

                                 # StringBuffer 

To overcome the problem of String class StringBuffer class is introduced which represents String in such a way that their data can be modified, it is mutable.

The methods that directly manipulate the data of the objects are not available in the String class but such methods are available in string buffer class.

Methods of StringBuffer - 

1. StringBuffer append(x) - This method insert the 'x' at the end of the String x may be Boolean,int etc.

2. StringBuffer insert(int i, x) - Here 'i' is a index and 'x' can be anything.

3. StringBuffer delete(int i, int j) - Here i and j are indexes.


                               # StringBuilder

It is similar to StringBuilder class. Its objects are also mutable.

StringBuffer class is synchronized but StringBuilder class is not synchronized.



 
                                   20/01/2025


                             # Exception Handling:-

there are different types of errors

1. syntax error - syntax errors are those which occur due to less knowledge of language.

2. Logical errors - logical errors arrives due to wrong logic or formula.

3. Runtime errors - runtime errors are those which occur if user enter invalid input to the program. because of invalid input we get some unknown message such messages are known as system generated message of error.

languages like java provide mechanism to handle these types of errors.


in java programming runtime errors are known as exceptions and exceptions always provide system error messages.

if an exception occur in java than program execution is abnormally terminated with the generation of system error message 

exception handling is the process of converting system error message into user friendly error message

Types of exceptions :-

there are two types of exceptions

1. Pre define exceptions(built in exceptions) - this are those exceptions which are developed by son microsystem and supplied as a part of JDK to deal with universal problems.

NumberFormatException
ArrayInexOutOfBoundsException
ArithmeticException
------
----
etc.

2. User define exceptions(custom exception) - these are those exceptions which are developed by java programmers and supplied as a part of their project to deal with their problems

for example:- 
1. trying to enter salary as a negative number for an employee.
2. entering a human age as 500.

Types of pre define exceptions 
there are two types of pre define exceptions

1. Asynchronous exception - this are those exceptions which deals with hardware problems and external problems like 
1. Power failure
2. motherboard failure
3. memory problems 
etc......

this are not used because son microsystem has not released any API for asynchronous exceptions 
They have given one base class called java.lang.Error

2. Synchronous exception - Synchronous exception are those which deals with programming runtime errors.
these are again classified into two types.

1. Checked exception - this are the sub-classes of java.lang.Exception.
this are called checked because compiler can check these exceptions at compile time only.

example:- 
1. FileNotFoundException
2. IOException
3. ClassNotFoundException

we can say that checked exceptions are those which are predictable and hence there handling mechanism is necessary to be given

2. Unchecked exception - Unchecked exceptions are those which are the subclasses of java.lang.RuntimeException 
These are not checked by the compiler because they occur during runtime 



                                    21/01/2025


java.lang.Throwable is the super class of all the exceptions and this class is used to decide that what type of exception has occurred

keywords related to exception handling

there are different keywords used in exception handling
1. try 
2. catch 
3. throw
4. finally
5. throws

try - it is a block in which we write the statements which can cause runtime errors during execution.
Whenever any exception occur in the try block than program flow is abnormally terminated and control comes out of the try block and execute appropriate catch block

catch - it is one of the block in which we write the statements which provide user friendly error message 
catch block will be executed if exception occur in try block
At any point of time only one catch block will be executed


*once control is transferred from try block it will never come back to try block

NOTE: we cannot have any statement between try and catch block

we cannot have any statement between two catch and catch and finally

catch with a super class exception can handle sub-class exception also


NOTE: if we will give single catch with parent class exception than we will not be able to give different different messages

NOTE: we can have multiple catch blocks for the same try block but those multiple catch blocks should be in ascending order of their inheritance hierarchy 


           
                                      22/01/2025

#Null pointer exception:-

#checked exception

#finally block :- this block always contain the block of statements which release/close the resources like files and database.

it is the last executable block in exception handling.

finally block will execute compulsory.

writing finally block is optional.

NOTE : we cannot write try block without catch and finally

we can write try block without catch block if finally is there in case of unchecked exception

we cannot write try block without catch if it contains checked exception

if there is a catch with checked exception than there should be at least one exception rising statements in try

The above rule is not applicable for unchecked exception



                                23/01/2025



if we have return statement in try block as well as all the catches than we cannot write any statement after that 

if we have return statement in try or catch than return value will be from try or catch but statements gives the finally block will be executed before returning

if we have return statement in try block as well as all the catches and in finally than always return statement of finally will be executed

if we have return statement in finally block than we cannot write even a single statement after finally 

if exception occurs then control jumps from try block to catch block. if we write System.exit than the code will be terminated hence this is the only case when finally block will not be executed.

numbers of ways to find details about unknown exception:-

1. By using an object of java.lang.Exception 

2. By using printStackTrace() method - it is one of the predefined method which is present in java.lang.Throwable class and it is inherited in java.lang.Exception class. it displays the following details:-
1. name of the unknown exception 
2. nature of the message
3. Line number where the exception has taken place

syntax:-

  void printStackTrace();


3. By using getMessage() method - it is a predefine method which display the nature of the exception

syntax :-

public String getMessage(); 

#class cast exception

#throws keyword:- it is a keyword which gives an indication to the specific method to place the common exception method with try and catch. 




                               24/01/2025

The process of propagation of object from called to calling is called ducking 

unchecked exceptions have auto-ducking

for checked exceptions there is no auto-ducking. we need to perform process of ducking for this purpose we will use the keyword throws to perform ducking

The advantage of this process is that rather than performing exception handling on specific place we can perform the process of ducking and we can bring the exception object from called method to calling place. it means we do not need to provide try and catch in different methods. 


Rule :- as we go from called place to calling place the hierarchy of exception object should increase but it should not decrease.


# throws related with overriding

rule :- in method overriding both the methods from child class and base class contains throws than as we go from base class to child class than child class overriding method can throw the same exception or sub class exception but cannot throw the super class exception 



                                    

                                   27/01/2025


#throw keyword - throw is a keyword used for generating or creating exception object explicitly. 

throw keyword must be used as a part of method body.


User define exception - with the help of throw keyword we can generate user define exception also. whenever we want to throw user define exception than the corresponding class must be child of runtime exception.

Note : while making user define exception our class should be child of RuntimeException class.
we are making our class as a child of RuntimeException because it is pure unchecked exception. here we need not to perform ducking because the process of auto-ducking is available in unchecked exception



				     28/01/2025

                                    Object Class

it is a class in java.lang package.it is the supermost class for all the classes in java

object class is important because of its methods. there are different methods in object class

1. toString

When we try to append an object to a string or if we try to print an object than toString methods will be called

If toString method is not present in our class than object class toString will be called

Each and every method in object class have default behaviour. if we want to change that behaviour than we need to override object class method in our class.

syntax of toString method in object class:-

public String toString()





                                  29/01/2025

#equals() method

in the above example equals method of object class will be called

the object class equals method have default behaviour which compares address

syntax of equals method

public boolean equals(object o);

# hashCode() method

hashcode is a integer representation of any object

for every object one unique number is generated by JVM this number is called hashcode.

in hashing related data structures while saving the objects JVM uses this hash code 

if we want to add any object to the hash table than first JVM will ask hash code than it will store the objects

syntax :-

public int hashCode();


# clone() method :- Suppose we have some objects on which we cannot perform direct action in this case we will use the concept of cloning. the main purpose here is to maintain backup copy

clone method is a protected method in class

syntax:- 

protected Object clone();

to preserve state of object cloning is required

if we want to perform cloning of our object than our class must be child of Cloneable interface

# Cloneable interface - cloneable is a marker interface

if interface does not contain any method than it is called marker interface

cloneable is a licence mechanism which provides permission for cloning




                                 #Wrapper class





                                         31/01/2025
  

                                  # Collection framework:- 

 

Drawbacks of array :- 
arrays are fixed in size

Student obj[] = new Student[10];

array is a group of homogenous elements	

obj[0] = new Student();
obj[1] = new Employee();            //gives error

arrays are not based on data structure. means they do not provide predefine methods.

collection is growable in nature

collection can store homogenous as well as heterogenous elements

collection is based on data structure. means it provides predefine methods	
Array is better performance wise. collection is growable but performance wise it is not good. if we know size in advance than go for array 

each time when requirement of size of collection changes than new object will be created and values of previous object will be copied into the new object and old object will be garbage collected 

collection is growable but internally lot of work is required hence performance will be decreased 

in terms of memory collection is better.

if we want to represent individual objects as a group in a single entity than we should go for collection

Note:- collection will not work on primitives. means we cannot store primitives inside the collection only objects are allowed

#collection framework:- is a group of classes and interfaces


                                      #Iterable 


it is an interface which contains iterator() method which allows elements traversal.

#collection interface

most common methods of collection framework are available inside the collection interface.

#collection v/s collections

collections is a utility class present in java.util package it provides methods for sorting and searching

Integer myInteger = "9";

Mehtods of collection interface : -

1. boolean add(object o) - it is used to add single object in a collection.

2. boolean addAll(collection c) - it is used to add all the objects of collection c in our collection.

3. boolean remove(object c) - it is used to remove single object from the collection.

4. Boolean removeAll(collection c) - it is used to remove all the objects of collection c from our collection

5. void clear() - This method is used to remove all the objects present in our collection.

6. Boolean retainAll(collection c) - this methods is used to retain all the objects of collection c and remove all other objects.

7. Boolean contains(object o) - it is used to check whether the object is present in our collection or not.

8. Boolean containsAll(collection c) - it is used to check whether all the objects of collection c are present in our collection or not.

9. Boolean isEmpty() - it is used to check whether the collection is empty or not.

10. int size() - it is used to find size of our collection. Means how many objects are available/present in our collection.

11. object[] toArray() - it is used to convert any collection into an array.

after conversion array will store objects.

collection interface has three child interface :-

1. List
2. Set
3. Queue

1. List :- it is an interface, if we want to represent group of object where duplicates are allowed and insertion order must be preserved, then go for List interface.

it is a child interface of collection.

2. Set :- It is a child interface of collection, if you want to represent group of objects where duplicates are not allowed and insertion order is also not preserved.

3. Queue :- It is a child interface of collection. if you want to represent group of objects in first-in-first-out order then go for Queue.

List - The implementation of list are ArrayList, LinkedList, Vector(subclass of Vector is Stack)

#Methods of List interface:-

1. Boolean add(int index, object o) - It is used to add object on particular index.

2. Boolean addAll(int index, collection c) - it is used to add all the objects of collection c on a particular index.

3. Boolean remove(int index) - it is used to remove object from particular index.

4. object get(int index) - it is used to return object from particular index.

5. void set(int index, object o) - it is used to set the object on particular index.

6. int indexOf(object o) - it is used to provide index of first occurrence of a object.

7. lastIndexOf(object o) - it is used to provide last index of a object.

#ArrayList - it is an implementation class of a list.

ArrayList is based on resizeable/growable array. The underlined of ArrayList is resizeable array. in ArrayList duplicates are allowed, insertion order is preserved.



                                      03/02/2025


Constructors inside the arrayList

1. Default constructor

ArrayList l = new ArrayList();

it creates an empty ArrayList but with default initial capacity and that capacity is 10. if 11th object comes than it will create another list and copy all the objects from previous list and re-assign the reference

new capacity = (current capacity*3/2)+1

the drawback of this constructor is if many objects will be added than performance will be decrease

to solve this problem another constructor is used

2.
ArrayList l = new ArrayList(int initialcapacity);

3. collection c

ArrayList<String> l = new ArrayList<String>(Collection c);

if we have another collection object like linked list and we want a parallel ArrayList of those objects than we pass that linked list as a parameter



                            04/02/2025


NOTE:- every collection class by default implements cloneable and serializable interface

ArrayList also implements RandomAccess interface

ArrayList is best when frequent operation is information retrieval 

ArrayList is worst if insertion and deletion in the middle is frequent operation 



                             #LinkedList

The underline data structure of LinkedList is doubly linked list

duplicates are allowed in linked list.

insertion order is preserve.

it is best when frequent operation is insertion and deletion in the middle

LinkedList is worst when our frequent operation is information retrieval.

in linkedList there are two constructors :-

1. LinkedList<String> l = new LinkedList<String>();

2. LinkedList<String> l = new LinkedList<String>(Collection c);

the concept of capacity is not in LinkedList because it is dynamic

to provide support for queue and stack LinkedList provide some methods 

1. addFirst("rashmika");
2. addLast("nakul");
3. removeFirst();
4. removeLast();
5. getFirst();
6. getLast();



                                    06/02/2025

#cursors 

if we want object from collection one by one then we use cursors 

there are three types of cursors

1. Iterator
2. ListIterator
3. Enumeration 

1. Iterator - Iterator can be used everywhere 

in Iterator read and remove both operations can be performed

Methods

1. public boolean hasNext()
2. public Object next()
3. public void remove()


#ListIterator

list can move in both direction. it is a bi-directional cursor.

it is a child interface of Iterator

Methods of ListIterator-

1. public void remove()
2. public object next()
3. public Boolean hasNext()
4. public int nextIndex()
5. public Boolean hasPrevious()
6. public int previous()
7. public void add(object)
8. public void set(object)
9. public void previousIndex()

NOTE - ListIterator is powerful but it is applicable for list objects



#vector

it is similar to arrayList its underline data structure is resizable array. it supports duplicates and insertion order is preserved.

vector is a child of cloneable, Serializeable, RandomAccess.

every method of vector is synchronized. means it is a thread safe collection. while arrayList is not synchronized

here size growth formula is :-


new capacity = old capacity*2;

if any one extra element comes than size will be doubled. To resolve this one extra constructor is used


there are four constructor in Vector

1. Vector v = new Vector();
2. Vector v = new Vector(10);
3. Vector v = new Vector(collection c);
4. Vector v = new Vector(int capacity, int increment);

         example - Vector v = new Vector(50,5);



                                      10_02_2025
                                        #Stack

It is similar to vector. it is a child of vector.
Duplicates are allowed, insertion order is preserved.
it is synchronized being a child of Vector


                                       #Enumeration

Enumeration works only for legacy class

legacy class means the classes which introduce in initial version of java.


                                          #Set

It is a child interface of collection.
duplicates are not allowed and insertion order is not preserved.

#HashSet : - It is a implementation class of Set.

the underline data structure is HashTable.
here all the objects will be inserted based on the hash code of the objects. 

HashSet implements Cloneable and Serializable interface.

HashSet is used when frequent operation is searching.

# Constructors inside the HashSet:-

1. Default :- this creates an empty HashSet with default initial capacity(16) and default fill ratio(load factor 0.75). 

the size of new object will be double.

HashSet<String> h = new HashSet<String>();

2. Initial capacity :- 


HashSet<String> h = new HashSet<String>(int initialCapaity);

3. fill ratio  


HashSet<String> h = new HashSet<String>(int initialCapacity, float fillratio);

4. 

HashSet<String> h = new HashSet<String>(Collection c);




                                  11/02/2025

                                #LinkedHashSet

if we want List and Set mixed property than go for LinkedHashSet

Underline data structure is Linked LinkedHashSet

in this duplicates are not allowed, and insertion order is preserved.

NOTE:- LinkedHashSet is a child of HashSet.

It is exactly same as HashSet including Constructors and methods.

it is introduced in version 1.4


                                #SortedSet

It is an interface, it is a child interface of Set.

If we want to represent group of objects where all objects should be according to some order like RollNo. wise than go for SortedSet.

Here duplicates are not allowed.

if sorted is there than we can find first element, Last element etc.

Methods :- 

1. first() - it gives first element

2. last() - it gives last element

3. headset(Object) - it returns SortedSet whose elements are less than given objects.

example:-

[100 101 104 106 110 115 120]

first - 100
last - 120
headset - 106 ---- 100 101 104

4. trailSet(object) - it will give SortedSet whose elements are greater than or equal to given object


example : - 

[100 101 104 106 110 115 120]

trailSet(106) ----- 106 110 115 120

5. subSet(obj1, obj2) - it will give the elements whose value is greater than or equal to obj1 and less than obj2.

example : - 

[100 101 104 106 110 115 120]

subset(101,115) - [101 104 106 110]

6. comparator() - it returns comparator object that describes sorting techniques. if default natural sorting is applied than it returns null.



                          #NavigableSet (interface)


It is a interface.
It is a child of SortedSet.
It is an extension of SortedSet. which provides navigation methods.
It provides methods to find lower(), higher(), floor(), etc.


                                    #TreeSet()

It is an implementation class of NavigableSet.
The underline data structure is balanceTree.
insertion order is not preserved.
Heterogenous elements not allowed.
Duplicates not allowed.



                                    12/02/2025
# Constructors in TreeSet

1. Default - here all the objects should be inserted according to natural sorting.

TreeSet t = new TreeSet();

2. TreeSet t = new TreeSet(Comparator c); :- this constructor is used for customized sorting given by Comparator object.

3. TreeSet t = new TreeSet(Collection c);

4. TreeSet t = new TreeSet(SortedSet s);


                                  # Comparable

It is an interface present in java.lang package it contains only one method that is compareTo()

syntax:- 

public int compareTo(Object o);

NOTE:- In TreeSet while inserting object JVM will call compareTo() method 


                                   #Comparator

It is an interface present in java.util package. it contains method compare()

syntax :-

public int compare(Object obj1, Object obj2);

If we want default sorting than go for Comparable, if we want customized sorting than go for Comparator.

In the above example we are not able to add Person in the TreeSet because it is not comparable



                                   14/02/2025

                                     # Map

It is not a child of collection it contains group of objects with key-value pair.

Every key is unique and values can be duplicate.

Collection methods cannot be applied here.

Methods of Map:-

1. Object put(Object key, Object value)

2. putAll(Map m)

3. Object get(key) -  it returns value of the corresponding key. If key doesn't exist then returns null.

4. remove(key) - it removes value of the corresponding key. If key doesn't exist then returns null.

5. boolean contains(value) - it returns true or false according to the existence of value in the Map.

6. boolean isEmpty()

7. size()

8. Set keySet() - if we want to make a set of all keys present in the map then we use keySet()

9. Collection values() - with the help of this method we can create collection  of all the values of the Map.

10. entrySet() - Map is considered as a group of entries so entry is an interface which is define within the Map.

Entry

interface Map{

	interface Entry{

		Object getKey();
		Object getValue(object o);
		Object setValue(Object o);
}
}


                                 # HashMap

It is an implementation class of Map. Here underline data structure is HashTable.

Insertion order is not preserved.

If frequent operation is search then go for HashMap.

It implements serializable and cloneable interface.

Constructors in HashMap:-

1. default - it creates empty HashMap with initial size 16 and fill ratio 0.75

   HashMap m = new HashMap();

2. HashMap m = new HashMap(int capacity);

3. HashMap m = new HashMap(int capacity, float fillratio);

4. HashMap m = new HashMap(Map m);




                                    15/02/2025

Hashtable

every table in Hashtable is synchronized but HashMap is not synchronized.

Hashtable is thread safe.

NOTE:- inside HashMap we can insert null value in a key.


H/W

1. how to synchronize HashMap?


#LinkedHashMap

It is exactly same as HashMap.

It is a child of HashMap.

Here underline data structure is LinkedList + Hashtable.

Here insertion order is preserved.




                                   # SortedMap



Here insertion will happen according to some sorting order.

Here sorting will be based on keys.

Methods:-

firstKey()
lastKet()
headMap(105)
trailMap()
subMap()


                                    # TreeMap

Here underline data structure is red black tree.

Here insertion order will be based on keys.

Here key cannot be repeat but values can be duplicate




                                 # NavigableMap





                                   18/02/2025

                               # Java 8 Features

Java 8 came in march 2014.

After java 8 the concept of functional programming enabled in java with the help of functional programming we can write less code 


                             # lambda expression.

The purpose of lambda expression is to enable functional programming.

this concept is taken from lambda calculus.

The first programming language which used lambda expression is LISP.

What is lambda expression?

lambda is the instance of functional interface.

It is an anonymous function. Means a function without name, without return type and without modifier.

How to write lambda expression?

public void m1(){

	SOP("Hello");
}


()->SOP("Hello");



If body contains only one line than we can remove curly brackets({}) also.


public void rashmika(int a, int b){

	SOP(a+b);

}


(int a, int b)->SOP(a+b);

Here compiler automatically detect the type, So we can remove the parameters type also.

(a,b)->SOP(a+b);

public int square(int n){

	return n*n;
}


(n)->return n*n;

Without curly brackets if we want to return something than no need to write return keyword also.

(n)->n*n;

If only single parameter is there than we can remove brackets also.

n->n*n;

public int m1(String s){

return s.length();

}

s->s.length();

public String m1(String s){

	return s.toUpperCase();

}

s->s.toUpperCase();




                            # Functional interface           (we Will prepare these following topics when we will prepare for interview)

If your interface contains only one method than it is called functional interface.

If interface contains single abstract method than it is called functional interface.

If we want to invoke lambda expression then compulsory functional interface required.

Examples:-

Runnable---- run()
Comparable------ compareTo()
Comparator------ compare()
Callable------ call()

interface I1{

void hello();           // It is functional interface

}


interface I1{

void hello();           // It is not a functional interface
void bye();

}


can we have default methods inside the functional interface?

we can have any number of default methods inside the functional interface

can we have static methods inside the functional interface?

we can have any number of static methods inside the functional interface.

@FunctionalInterface - this annotation is used to specify that the given interface is a functional interface.

It is optional annotation.

can we have private methods inside the functional interface.
 
we can have any number of private methods inside the functional interface.



               # lambda expression with functional interface







                                   24/02/2025



                                   # Function

It is a predefine functional interface which provide some result 
it contains one method :-

public R apply(T t):-


                                  #Consumer

consumer is a predefine functional interface. it will not return anything means it is going to consume the value

interface Consumer<T>{

public void accept(T t);

}


                                  # Supplier

It is an predefine functional interface which is used to supply some result it will not take any input

interface Supplier<R>{

public R get();

}



                                # BiPredicate

BiPredicate will receive two parameters and return boolean 


                                 #BiFunction

It will take two inputs and return one output.


                                 #BiConsumer

it will accept two input



                                 #Stream API

the Stream API in java is used for processing collections of data in a functional way.

it uses functional programming techniques.

It allow performing operations like filtering, maping, sorting etc.

A Stream is a sequence of elements from a data source that supports various operations to process the data in a pipeline.

unlike list or set, a stream does not store elements.

it uses lambda expression and support functional programming.

general points

a java Stream provides variety of methods that can be classified into two main categories.

1. intermediate operations.
2. Terminal operations.

1. Intermediate operations return a new Stream and are executed only when terminal operation is called.

2. Terminal operation triggers the execution of Stream pipeline and return a known Stream result.


l.stream() - stream is method which is used to provide object of stream 

Stream s = l.stream() 

here Stream is interface, l is a collection, stream() is a method and s is reference.


filter() - the filter method is used to select elements as per the predicate passed as an argument.

collect(Collerctors.toList());  -  It used to collect the final processed result into the another list. 

collect() - the collect method is used to return the result of the intermediate operations performed on the stream


map() - map method is used to return a stream consisting of the results of the given function in the elements of the stream. map method takes function as a parameter.

                                          
 
 
                                        26/02/2025

                                         #count()

It is a terminal operation which returns the number of elements in the stream. The return type of count method is long.


# forEach()

it is terminal method which is used to perform an action for each element.


#anyMatch() - 

it is terminal operation which is used to check if any element matches a condition.


# allMatch()-

it is terminal operation which is used to check if all element matches a condition.

#noneMatch() - 

it is terminal operation which is used to check if none of the element matches a condition.


                                    #Optional class

The optional class in java introduced in java 8.

It is a container object that may or may not contain a non-null value.

it helps to avoid NullPointerException and makes the code more readable.



# Things to do in future :-

all remaining methods of String.

method reference.

constructor reference.

date time API.

more types of predicate consumer, supplier etc.

Optional class in detail.



                                          28/02/2025

                                       # Multi threading

Java programming developing multithreading very easy because maximum work is done by API.

Java provides inbuilt support for multithreading.

/*
 * program to understand Multithreading 
 */

class Mythread extends Thread{

    public void run(){

        for(int i=0; i<60; i++){

            System.out.println("Mythread");
        }
    }
}

class Main{

    public static void main(String[] args) {
        
        Mythread t = new Mythread();
        t.start();

        for(int i=0; i<60; i++){

            System.out.println("Main");
        }
    }
}

In the above example main thread starting child thread when we write t.start() it will first check start method in our class, if not found it will check in thread class.

Thread class start() method internally calls our run() method.

start(){

   1. register this thread with thread schedular.
   2. perform all activities.
   3. call run() method of our class.
}

If we are not overriding run() method in our class then thread class run() method will be called which has empty implementation. and hence will not get any result.

If we create start() method in our class then there will not be any multithreading. 


Another way of creating thread.

by using Runnable interface we can achieve multithreading in java.

Runnable is a interface present in java.lang package it contains only one method called run method.

problem with previous technique of extending thread class is we cannot inherit the features of another class by inheriting thread class.

How to stop thread execution.

There are different methods which are used to stop thread execution.

1. yield()
2. join()
3. sleep()

1. yield() - it is static method in thread class.

suppose there are many threads existing and the first thread is taking lot of time, but second thread wants to take less time to complete.

Whenever yield() method is execute then the current thread execution will be paused to give the chance to another thread.

2. join() - in case of interdependency join() method is used. if a threads wants to wait until completion of some other thread then we use join().

Suppose we have two threads if one thread wants to wait until completion of another thread then the thread has to write join() method.

3. sleep() - sleep method is used to pause a thread for a particular time. Means if a thread does not want to go for any operation then we apply sleep() method.


Topics to cover in multithreading in future.
1. Deadlock 
2. thread Synchronization
3. Inter thread communication
    etc...


                                        03/03/2025

                                     # File Handling

to store data in secondary memory we use files.

File - file is a container which is used to store data.

#PrintWriter

It is the most powerful and enhance writer to write data in a file.


# FileReader
to read a data from a file FileReader is used.

Constructors - 

FileReader fr = new FileReader(String fname);

FileReader fr = new FileReader(File f);


import java.io.FileReader;
import java.io.IOException;
 
 
  class Main{
  
      public static void main(String[] args) throws IOException {
          
         FileReader fr = new FileReader("info.txt");

         int i = fr.read();

         while(i!= -1){

            System.out.println((char)i);
            i = fr.read();
         }
         fr.close();
 
          System.out.println("done");
      }
  }



In the above example read() is predefine method of FileReader. it reads character by character and return their UNICODE. 


# BufferReader

To read data line by line BufferedReader is used BufferdReader cannot communicate directly with file, it require another Reader.

# Things to cover in future
1. Serialization

2. Deserialization

3. extrelization.

4. transient(keyword)

etc...



                              # Database Management System(DBMS)

Data is a facts that can be recorded. for example text, numbers, images, etc.

# Database

Collection of related data that represents some real world entities is called database. example university database may contain records of student, teachers, courses, etc.

# DBMS 

Database management system is a software for storing and retrieving users data while considering the appropriate security measures.

It consist of group of programs which manipulate the database.

DBMS allow user to create their own database as per their own requirement.

h/w 

d/b file system and DBMS


                                      06/03/2025

                                        # SQL

SQL is language which is used to communicate with the database server.

# MySQL 

MySQL is an opensource relational database management system that uses structured query language to manage data.

# DDL(data definition language)

DDL commands deals with the structure of objects.

they interact with database directly.

DDL commands enforce an implicit commit before and after the statement.

We cannot undo the changes performed by DDL commands.

Example :- create, alter, truncate etc..

# DML(Data manipulation language)

DML commands deals with the data only.

They are used to insert, update, delete and modify data in tables.

DML commands interact with the buffer first and then with the database on commit.

We can perform the rollback or undo the changes.

If we perform rollback then buffer data will be removed from the database.

# DQL(data query language)

This are used to retrieve data from a database.

Example - select.

TCL (Transaction control language)

this commands deals with transactions only.

Set of DML operations with commit or rollback is a transaction.

Every transaction start with DML operation and commit, rollback is a ending point to this transactions.

These commit or rollback may be implicit or explicit

example - commit, rollback, save point.


# DCL(Data control language)

DCL commands used to control access to data. it means the deal with privileges or permissions.

They interact with the database directly.

example - grant, revoke, setroll etc...


Commands :-

show databases - it is used to show all the databases.

create database - it is used to create database.

use - it is used to select database.

drop database - it is used to delete database.

show tables

we can create field name same as table name.

create table t(t int);

create table another as select * from student;

create table another1 as select * from student where 1=2; 

in the following command if we write 1=1 then the data of previous table copied to new table. if we write 1=2 then it only copy the structure of table.

rename table another to employee; - it is used to change the name of objects.

drop table t; - it is used to delete table.


# alter



alter table student add(salary int); - it is used to add new columns in table.

alter table student drop column salary; - it is used to delete a column from a table.

alter table student modify name varchar(40); - it is used to modify the properties of a field.		

Truncate command is used to remove all the data from the table.

insert into student(id, name) values(101, "katappa"); - it is used to insert values in table and if we want to give value of any specific column then we can use it.

insert into student values(102, "xyz"); - it is used to insert values in table and if we want to give value of any specific column then we cannot use it.


insert into student values("xyz",901); 

ERROR 1336(HY000): incorrect integer values

insert into student(name, id) values("xyz", 901);


NOTE: - If we insert data in same order where table created then no need to provide column list.

If we are providing all the values but order not follow then we need to provide column list.

If we are not providing all values then also column list required.

# Inserting data in one table from another table:- 

insert into student(name,id) values("bahubali", 501);

insert into student1 select * from student;

# update command - 

update command is used to modify existing data we can change data of one column or multiple columns

update student1 set name='rashmika'; - it is used to update the data of column but in these all rows gets affected. meaning the name of all the entries changes to rashmika.

update student set name='rashmika' where id=102; - in this command it changes the name of id = 102;

# delete - 

It is used to remove data from the tables.

we can delete single records, multiple records or all the records.

delete from student where name='bahubali'; - it is used to delete specific entry.

delete from student where name='xyz';


delete - 1) it is a DML command.

2) Here rollback is possible.

3) implicit commit not available.

4) in case of delete single row can be deleted.

5) In delete command we can use 'where'


truncate - 1) It is a DDL command.

2) Here rollback is not possible.

3) Implicit commit available

4) single row cannot be truncated.

5) In truncate command we cannot use 'where'

# SQL clauses:

where:- it will eliminate the non-matching records

select * from student where name='katappa';

it has highest priority. 

it will be processed before all other optional clauses.

it should be placed at first position.

Group functions are not allowed in where clause. because group function can be processed after forming the groups.

where can be used in select, update, delete.





                                  10/03/2025 

                              Aggregate Function

Aggregate functions act on column data only.

there are different aggregate functions available.

Aggregate function perform calculations on set of values and return a single value.

# sum :-

It is used to add all values in a column and display result.

mysql> select * from emp1;
+------+----------+--------+
| id   | name     | salary |
+------+----------+--------+
|  101 | rashmika |   9000 |
|  102 | deepika  |  18000 |
|  103 | mahesh   |   1000 |
+------+----------+--------+
3 rows in set (0.00 sec)

mysql> select sum(salary) from emp1;
+-------------+
| sum(salary) |
+-------------+
|       28000 |
+-------------+
1 row in set (0.00 sec)

we can alias of column

mysql> select sum(salary) as Total from emp1;
+-------+
| Total |
+-------+
| 28000 |
+-------+
1 row in set (0.00 sec)


# Average :-


mysql> select avg(salary) as Total from emp1;
+-----------+
| Total     |
+-----------+
| 9333.3333 |
+-----------+
1 row in set (0.00 sec)



# max - 

find highest values from a given column.

mysql> select max(salary) as LARGEST from emp1;
+---------+
| LARGEST |
+---------+
|   18000 |
+---------+


# min :- 

mysql> select min(salary) as LOWEST from emp1;
+--------+
| LOWEST |
+--------+
|   1000 |
+--------+
1 row in set (0.00 sec)


# count :- 

It is used to count not null values from a given column.

mysql> select * from emp1;
+------+----------+--------+
| id   | name     | salary |
+------+----------+--------+
|  101 | rashmika |   9000 |
|  102 | deepika  |  18000 |
|  103 | mahesh   |   1000 |
|  104 | bahubali |   NULL |
+------+----------+--------+
4 rows in set (0.00 sec)

mysql> select count(salary) as count from emp1;
+-------+
| count |
+-------+
|     3 |
+-------+

mysql> select count(*) as count from emp1;
+-------+
| count |
+-------+
|     4 |
+-------+


# numeric functions

1. absolute

mysql> select abs(-9) from dual;
+---------+
| abs(-9) |
+---------+
|       9 |
+---------+
1 row in set (0.00 sec)


2. power(5,2) 

mysql> select power(5,2) from dual;
+------------+
| power(5,2) |
+------------+
|         25 |
+------------+



                                # groupby :-

It is used to form groups. it will be processed after where clause. If where clause is not there then we can place groupby directly.


NOTE:- All the optional clauses will be processed in the buffer not in the database 


mysql> create table emp5(id int, name varchar(20),department varchar(30), jobrole varchar(30),salary int);
Query OK, 0 rows affected (0.04 sec)

mysql> desc emp5;
+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| id         | int         | YES  |     | NULL    |       |
| name       | varchar(20) | YES  |     | NULL    |       |
| department | varchar(30) | YES  |     | NULL    |       |
| jobrole    | varchar(30) | YES  |     | NULL    |       |
| salary     | int         | YES  |     | NULL    |       |
+------------+-------------+------+-----+---------+-------+


mysql> select * from emp5;
+------+----------+------------+-----------+--------+
| id   | name     | department | jobrole   | salary |
+------+----------+------------+-----------+--------+
|  101 | rashmika | HR         | manager   |   9000 |
|  102 | deepika  | IT         | developer |   8000 |
|  103 | bahubali | HR         | recruiter |   5000 |
|  104 | katappa  | IT         | tester    |   2000 |
|  105 | vivek    | finance    | manager   |   9000 |
+------+----------+------------+-----------+--------+
5 rows in set (0.00 sec)


counting the number of employees in each department


mysql> select department,count(*) as count from emp5 group by department;
+------------+-------+
| department | count |
+------------+-------+
| HR         |     2 |
| IT         |     2 |
| finance    |     1 |
+------------+-------+
3 rows in set (0.00 sec)


We want to find total salary according to department wise.

mysql> select department,sum(salary) as total from emp5 group by department;
+------------+-------+
| department | total |
+------------+-------+
| HR         | 14000 |
| IT         | 10000 |
| finance    |  9000 |
+------------+-------+
3 rows in set (0.00 sec)


# having clause:-

It is used to eliminate the groups.

It is similar as where clause but where clause eliminates records but having eliminates groups.

where clause filter records before grouping, but having clause filter records after grouping.


mysql> select department,sum(salary) as total from emp5 group by department having sum(salary)>9500;
+------------+-------+
| department | total |
+------------+-------+
| HR         | 14000 |
| IT         | 10000 |
+------------+-------+
2 rows in set (0.00 sec)

NOTE:- first data will be copied from database to buffer 

now group by applied means groups are formed.

now aggregate function is applied on each group.

after this with the help of having clause non-matching groups are eliminated.


                             # order by

It is used to sort results either in ascending or descending order.

mysql> select * from emp5 order by salary;
+------+----------+------------+-----------+--------+
| id   | name     | department | jobrole   | salary |
+------+----------+------------+-----------+--------+
|  104 | katappa  | IT         | tester    |   2000 |
|  103 | bahubali | HR         | recruiter |   5000 |
|  102 | deepika  | IT         | developer |   8000 |
|  101 | rashmika | HR         | manager   |   9000 |
|  105 | vivek    | finance    | manager   |   9000 |
+------+----------+------------+-----------+--------+
5 rows in set (0.00 sec)

In descending order

mysql> select * from emp5 order by salary desc;
+------+----------+------------+-----------+--------+
| id   | name     | department | jobrole   | salary |
+------+----------+------------+-----------+--------+
|  101 | rashmika | HR         | manager   |   9000 |
|  105 | vivek    | finance    | manager   |   9000 |
|  102 | deepika  | IT         | developer |   8000 |
|  103 | bahubali | HR         | recruiter |   5000 |
|  104 | katappa  | IT         | tester    |   2000 |
+------+----------+------------+-----------+--------+
5 rows in set (0.00 sec)


mysql> select * from emp5 order by id desc, salary desc;
+------+----------+------------+-----------+--------+
| id   | name     | department | jobrole   | salary |
+------+----------+------------+-----------+--------+
|  105 | vivek    | finance    | manager   |   9000 |
|  104 | katappa  | IT         | tester    |   2000 |
|  103 | bahubali | HR         | recruiter |   5000 |
|  102 | deepika  | IT         | developer |   8000 |
|  101 | rashmika | HR         | manager   |   9000 |
+------+----------+------------+-----------+--------+
5 rows in set (0.00 sec)

in this first it will sort on the basis of id if two employee id got same then it sort on basis of salary.


NOTE:- order by clause has least priority 

mysql> select department,sum(salary) as total from emp5 group by department having sum(salary)>9500 order by total;
+------------+-------+
| department | total |
+------------+-------+
| IT         | 10000 |
| HR         | 14000 |
+------------+-------+
2 rows in set (0.00 sec)


mysql> select department,sum(salary) as total from emp5 where salary>6000 group by department;
+------------+-------+
| department | total |
+------------+-------+
| HR         |  9000 |
| IT         |  8000 |
| finance    |  9000 |
+------------+-------+
3 rows in set (0.00 sec)



                                       11/03/2025

                                         # keys

To find data from a database table we need keys.

It is used to uniquely identify any record or data from table.

Types of keys:-

1. super key

super key is an attribute set that can uniquely identify a tuple(row).

it is super set of all key


example:-  EmpId        name              aadhar           sal               contact            mail


super key:- empId
            aadhar
            {empId,name}
            etc....


                                 # candidate key

It is an attribute or set of attribute that can uniquely identify a tuple(row).

Minimal set of super key is called candidate key.


                                  # primary key

Any key which is selected for our database from the candidate key is called primary key

primary key cannot be null.

duplicates are not allowed in primary key.


                                 # alternate key

All candidate keys except primary key will be considered as alternate key 

total number of alternate key is the total number of candidate key - total number of primary key.


                                   # unique key

It is also similar to primary key but it will allow null value. 

Example :- we can consider Email as an unique key.


                                    # foreign key


This key is used to relate one table with another table.

Foreign keys are the column of one table which are used to point primary key of another table.


                                   # composite key

Whenever a primary key consist of more than one attribute then it is known as composite key.

Example - {name,address}


                                    # constraints 

constraints are the rules or restrictions based on our requirement.

constraints are classified in three groups

1. domain integrity -

A group of values in a single column is called domain.

To maintain data integrity we use domain constraints.

domain constraints can be defined on single column only.

# not null - It does not allow null values.

It can be defined on one column only.

It can be defined at column level only.

# default - Whenever we do not insert any value than those values will be filled by default value  

examples - default, not null, check

mysql> use beans;
Database changed
mysql> create table employee1(id int, name varchar(20) not null,salary int default 10000);
Query OK, 0 rows affected (0.09 sec)

mysql> desc employee1
    -> ;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int         | YES  |     | NULL    |       |
| name   | varchar(20) | NO   |     | NULL    |       |
| salary | int         | YES  |     | 10000   |       |
+--------+-------------+------+-----+---------+-------+
3 rows in set (0.04 sec)

mysql> insert into employee1 values(101,'rashmika',8000);
Query OK, 1 row affected (0.02 sec)

mysql> select * from employee1;
+------+----------+--------+
| id   | name     | salary |
+------+----------+--------+
|  101 | rashmika |   8000 |
+------+----------+--------+
1 row in set (0.00 sec)

mysql> insert into employee1(id, name) values(102,'deepika');
Query OK, 1 row affected (0.07 sec)

mysql> select * from employee1;
+------+----------+--------+
| id   | name     | salary |
+------+----------+--------+
|  101 | rashmika |   8000 |
|  102 | deepika  |  10000 |
+------+----------+--------+
2 rows in set (0.00 sec)

mysql> insert into employee1(id, salary) values(102,12000);
ERROR 1364 (HY000): Field 'name' doesn't have a default value


-------------------------------------------------------------------

# check

mysql> create table emp6(eno int,name varchar(20) not null, deptno int check(deptno in(10,20,30)));
Query OK, 0 rows affected (0.09 sec)

mysql> select * from emp6;
Empty set (0.00 sec)

mysql> desc emp6;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| eno    | int         | YES  |     | NULL    |       |
| name   | varchar(20) | NO   |     | NULL    |       |
| deptno | int         | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

mysql> insert into emp6 values(101, 'abc',80);
ERROR 3819 (HY000): Check constraint 'emp6_chk_1' is violated.
mysql> insert into emp6 values(101, 'abc',10);
Query OK, 1 row affected (0.07 sec)

2. Entity integrity -

Entity means object we can define constraints at object level or table level.

1. unique:- it does not allow duplicate values.

It allow null values.

It can be define on one or more columns.


mysql> create table emp7(id int unique, name varchar(20) not null);
Query OK, 0 rows affected (0.07 sec)

mysql> insert into emp7 values(101,'abc');
Query OK, 1 row affected (0.07 sec)

mysql> insert into emp7 values(101,'abc');
ERROR 1062 (23000): Duplicate entry '101' for key 'emp7.id'


# primary key:-

In case of primary key duplicate values are not allowed and null values are also not allowed



mysql> create table emp8(id int primary key, name varchar(20) not null);
Query OK, 0 rows affected (0.04 sec)

mysql> desc emp8;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int         | NO   | PRI | NULL    |       |
| name  | varchar(20) | NO   |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)

mysql> insert into emp8 values(101,'aaa');
Query OK, 1 row affected (0.02 sec)

mysql> insert into emp8(name) values('aaa');
ERROR 1364 (HY000): Field 'id' doesn't have a default value


unique + not null!=== primary key

examples - unique, primary key


# composite key :- 

mysql> create table emp20(name varchar(20), address varchar(20), mobile int, primary key(name,address));
Query OK, 0 rows affected (0.03 sec)

mysql> desc emp20;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | NO   | PRI | NULL    |       |
| address | varchar(20) | NO   | PRI | NULL    |       |
| mobile  | int         | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
3 rows in set (0.01 sec)

mysql> insert into emp20 values('nakul','indore',454545);
Query OK, 1 row affected (0.07 sec)

mysql> insert into emp20 values('nakul','indore',267854565);
ERROR 1062 (23000): Duplicate entry 'nakul-indore' for key 'emp20.PRIMARY'
mysql>

3. referential integrity - examples - foreign key.

foreign key :-

It is used for joining the table.

In foreign key duplicates values are allowed.

Any number of Null values are allow.



Practical example :-  


mysql> create table department(did int primary key, name varchar(20) not null);
Query OK, 0 rows affected (0.07 sec)

mysql> create table student5(sid int primary key,name varchar(20) not null, deptid int,foreign key(deptid) references department(did));
Query OK, 0 rows affected (0.15 sec)

mysql> desc student5;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| sid    | int         | NO   | PRI | NULL    |       |
| name   | varchar(20) | NO   |     | NULL    |       |
| deptid | int         | YES  | MUL | NULL    |       |
+--------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)

mysql> insert into department values(10,'CS'),(20,'EC');
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> select * from department;
+-----+------+
| did | name |
+-----+------+
|  10 | CS   |
|  20 | EC   |
+-----+------+
2 rows in set (0.00 sec)


# here error occurs bcoz student5 is refers to department and we have to enter matching values.

mysql> insert into student5 values(101,'rashmika',50);
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`beans`.`student5`, CONSTRAINT `student5_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `department` (`did`))

# here we did not allot any department to rashmika


mysql> insert into student5(sid,name) values(101,'rashmika');
Query OK, 1 row affected (0.07 sec)

mysql> select * from student5;
+-----+----------+--------+
| sid | name     | deptid |
+-----+----------+--------+
| 101 | rashmika |   NULL |
+-----+----------+--------+
1 row in set (0.00 sec)


# duplicates are allowed in foreign key


mysql> insert into student5 values(102,'deepika',10),(103,'katappa',10);
Query OK, 2 rows affected (0.06 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> select * from student5;
+-----+----------+--------+
| sid | name     | deptid |
+-----+----------+--------+
| 101 | rashmika |   NULL |
| 102 | deepika  |     10 |
| 103 | katappa  |     10 |
+-----+----------+--------+
3 rows in set (0.00 sec)

# here error occurs bcoz we cannot delete column if the connection is done in two tables here id 10 is refers two students and id 20 is not refers any student.

mysql> delete from department where did = 20;
Query OK, 1 row affected (0.02 sec)

mysql> delete from department where did = 10;
ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`beans`.`student5`, CONSTRAINT `student5_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `department` (`did`))
mysql>




By default if you create a foreign key in MySQL without specifying on delete or on update options then MySQL enforces restrict behaviour.

We cannot delete or update a parent row if there are child rows referring to it


                                       13/03/2025


we want to change the foreign key so first we need to drop the existing foreign key then we need to add new foreign key.

alter table emp20 drop foreign key emp20_ibfk_1; (this query is droping the existing foreign key)


alter table emp20 add foreign key(deptid) reference dept6(did) on delete cascade on update cascade;               (this query is used to add new foreign key with no restrictions).


update dept6 set did = 90 where did = 10; (now we can update the constraints but it can change the child elements also, like if we update the department id then it automatically update the foreign keys in employees table)


code---------------


if we use on update cascade then all the child records updated automatically if the parent record is updated


code ----------------

delete from dept6 where did=20;


if we use on delete cascade then all the child records deleted automatically if the parent record is deleted.


# joins

joins are used to combine two or more tables 



practical example:- 


mysql> create table emp30(eid int,ename varchar(20),deptid int);
Query OK, 0 rows affected (0.10 sec)

mysql> create table dept30(did int,dname varchar(20));
Query OK, 0 rows affected (0.09 sec)

mysql> insert into dept30 values(101,'HR'),(102,'IT'),(103,'Sales'),(104,'marketing');
Query OK, 4 rows affected (0.07 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> select * from dept30;
+------+-----------+
| did  | dname     |
+------+-----------+
|  101 | HR        |
|  102 | IT        |
|  103 | Sales     |
|  104 | marketing |
+------+-----------+
4 rows in set (0.00 sec)

mysql> insert into emp30 values(1,'rashmika',101),(2,'deepika',102);
Query OK, 2 rows affected (0.07 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> insert into emp30(eid,ename) values(3,'katappa');
Query OK, 1 row affected (0.07 sec)

mysql> insert into emp30 values(4,'bahubali',103),(5,'shivgami',110);
Query OK, 2 rows affected (0.07 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> select * from emp30;
+------+----------+--------+
| eid  | ename    | deptid |
+------+----------+--------+
|    1 | rashmika |    101 |
|    2 | deepika  |    102 |
|    3 | katappa  |   NULL |
|    4 | bahubali |    103 |
|    5 | shivgami |    110 |
+------+----------+--------+
5 rows in set (0.00 sec)


1. inner join :-

an inner join is used to retrieve records that have matching values both tables being join


mysql> select emp30.ename,dept30.dname from emp30 inner join dept30 on emp30.deptid=dept30.did;
+----------+-------+
| ename    | dname |
+----------+-------+
| rashmika | HR    |
| deepika  | IT    |
| bahubali | Sales |
+----------+-------+
3 rows in set (0.00 sec)


2. left join/ left outer join :-

It returns all the records from the left table with matching records from the right table, if no match is found then Null is returned.

mysql> select emp30.ename,dept30.dname from emp30 left join dept30 on emp30.deptid=dept30.did;
+----------+-------+
| ename    | dname |
+----------+-------+
| rashmika | HR    |
| deepika  | IT    |
| katappa  | NULL  |
| bahubali | Sales |
| shivgami | NULL  |
+----------+-------+
5 rows in set (0.00 sec)


topic that are imp but not covered in MySQL

1. Dcl commands
2. tcl commands
3. sub query/nested query
4. normalization
5. association and its types
6. stored procedure
7. views 
8. triggers









                                        17/03/2025

execute update - it is applicable for non-select queries.

All DMM commands are non-select commands.

here return type is number of rows updated, deleted or inserted.

syntax :-

public int executeUpdate(query);

3. execute :- 

We can use execute method for both select and non-select operations.

At run time end user may provide select or non-select query. means at the beginning we do not know what type of query will arise.

Syntax :-

public boolean execute(query);

Boolean b = st.execute(query);

if(b==true){

ResultSet = st.getResultSet();

-------------
--------

}

else{

int rowCount = st.getUpdateCount();

}



methods that are used for navigate:--

Boolean next():- it moves to the next row. It returns false if no more rows exist.

Boolean first();  - It moves to the first row.

Boolean last(); - it moves to the last row.

etc....


Data retrieval methods:-

int getInt(String) - it retrieves an int value.

String getString(String);  -  It retrieves an String value.




                                           18/03/2025

                             # life cycle of a sql query execution

Statement st = ------------;
ResultSet rs = st.executeQuery(query)--------;

In the above line sql query will go to the database.

the database site database engine is responsible to receive our sql query.

database engine will perform two activities.

1. compile that query means compilation.

2. if no error then execute that query that is execution.

In compilation process many activities are perform like -

1. tokenization
2. parsing
3. query optimization.


Drawback of Statement :-

In case of statement every time query will be compile so performance will decrease.

The problem of Sql injection is also available in case of statement



                               # PreparedStatement

A preparedStatement is a precompiled SQL statement that allow you to execute parameterized queries efficiently.

In case of prepareStatement we pass query.

Database engine will compile that query and store that query in the form of preparedStatement.

The problem of SQL injection is not available in case of prepared statement.


# Limitations of preparedStatement :-

In case of normal statement object we can work with multiple queries like insert, delete, update etc.

But in case of preparedStatement we can work only with one query.

Same preparedStatement object cannot work with insert and delete.

# H/W - 

1 statement vs preparedStatement

2. jdbc till now

3. all crud operations

4. dynamic queries


# topic to be covered in future

1. callableStatement
2. SqlInjection
3. rowSet
etc....